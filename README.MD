# Лабораторная 2

## Задание 1

**Что сделано:**
- **Реализовал интерфейс для выгрузки конфигураций из внешнего сервиса:**  
  Обеспечил пагинированную загрузку данных, параметризуемую по размеру страницы.
- **Реализовал две версии клиента:**
  - Версия с ручной реализацией запросов на базе `HttpClient`, получаемого через `IHttpClientFactory`.
  - Версия с использованием библиотеки **Refit**, при этом основной интерфейс не зависит от Refit.
- **Добавил методы расширения для регистрации клиентов в DI:**  
  Предусмотрел отдельные методы для регистрации каждой из реализаций.

## Задание 2

**Что сделано:**
- **Разработал собственный `ConfigurationProvider`:**  
  Получение конфигураций организовано через обслуживающий сервис, который обращается к клиенту из Задания 1.
- **Обеспечил периодическую актуализацию конфигураций:**  
  Для обновления через определённый интервал времени использовал `PeriodicTimer`, сделав интервал обновления параметризуемым.
- **Реализовал логику сравнения конфигураций:**  
  Провайдер не перезагружает конфигурации при отсутствии изменений, тем самым оптимизируя работу и избегая лишних обновлений.
- **Написал тесты, покрывающие различные сценарии обновления:**  
  Включая ситуации с добавлением новой конфигурации, отсутствием изменений, обновлением значения по ключу и очисткой набора конфигураций.

## Задание 3

**Что сделано:**
- **Разработал репозитории для товаров, заказов, позиций заказов и истории заказов**, ориентируясь на предоставленную схему данных.
- **Реализовал пагинацию и фильтрацию:**  
  В репозиториях предусмотрены методы для пагинированного поиска с различными критериями, включая идентификаторы, диапазоны цен, статусы и подстроки.
- **Добавил миграции через FluentMigrator и SQL:**  
  Обеспечил автоматический запуск миграций при старте приложения, используя методы расширения для регистрации в DI.
- **Использовал Npgsql для работы с PostgreSQL:**  
  Все операции чтения/записи реализованы через SQL-запросы и `NpgsqlCommand`.
- **Реализовал полиморфную сериализацию в репозитории истории заказов:**  
  Для записи и чтения исторических записей применил `System.Text.Json`, обеспечив хранение различных типов исторических событий.
- **Обеспечил транзакционность бизнес-операций в сервисе заказов:**  
  Операции по созданию заказа, добавлению и удалению позиций, смене статуса и формированию истории выполняются в транзакциях.
- **Добавил сервисы для работы с товарами и заказами:**  
  Реализовал функционал создания товаров, создания заказа, добавления и удаления товаров из заказа в статусе `created`, перевода заказа в `processing`, его выполнения (`completed`), отмены (`cancelled`) и пагинированного получения истории изменений.
- **Получение конфигураций для подключения к БД из кастомного конфигурационного провайдера:**  
  Обеспечил гибкую настройку, используя механизм Options и данные, получаемые через Задание 2.

## Демонстрационный сценарий

**Что сделано:**
- **Реализовал отдельное консольное приложение для тестирования интеграций:**
  1. Загрузил конфигурации из внешнего сервиса.
  2. Создал несколько товаров.
  3. Создал заказ.
  4. Добавил товары в заказ.
  5. Удалил один товар из заказа.
  6. Перевёл заказ в работу (`processing`).
  7. Выполнил заказ (`completed`).
  8. Вывел в консоль всю историю заказа.
  
- **Предусмотрел отдельную базу данных для тестирования:**  
  Для этого расширил `docker-compose` дополнительным сервисом базы данных, не пересекающимся с БД сервиса конфигураций.

